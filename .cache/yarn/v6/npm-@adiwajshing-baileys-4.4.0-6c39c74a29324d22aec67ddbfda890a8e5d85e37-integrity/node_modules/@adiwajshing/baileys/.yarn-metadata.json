{
  "manifest": {
    "name": "@adiwajshing/baileys",
    "version": "4.4.0",
    "description": "WhatsApp API",
    "homepage": "https://github.com/adiwajshing/Baileys",
    "main": "lib/index.js",
    "types": "lib/index.d.ts",
    "keywords": [
      "whatsapp",
      "js-whatsapp",
      "whatsapp-api",
      "whatsapp-web",
      "whatsapp",
      "whatsapp-chat",
      "whatsapp-group",
      "automation",
      "multi-device"
    ],
    "scripts": {
      "test": "jest",
      "prepare": "tsc",
      "build:all": "tsc && typedoc",
      "build:docs": "typedoc",
      "build:tsc": "tsc",
      "example": "node --inspect -r ts-node/register Example/example.ts",
      "example:legacy": "node --inspect -r ts-node/register Example/example-legacy.ts",
      "gen-protobuf": "sh WAProto/GenerateStatics.sh",
      "browser-decode": "yarn ts-node src/BrowserMessageDecoding.ts",
      "lint": "eslint ./src --ext .js,.ts,.jsx,.tsx",
      "lint:fix": "eslint ./src --fix --ext .js,.ts,.jsx,.tsx"
    },
    "author": {
      "name": "Adhiraj Singh"
    },
    "license": "MIT",
    "repository": {
      "url": "git@github.com:adiwajshing/baileys.git"
    },
    "dependencies": {
      "@hapi/boom": "^9.1.3",
      "axios": "^0.24.0",
      "futoin-hkdf": "^1.5.0",
      "libsignal": "git+https://github.com/adiwajshing/libsignal-node",
      "music-metadata": "^7.12.3",
      "node-cache": "^5.1.2",
      "pino": "^7.0.0",
      "protobufjs": "^6.11.3",
      "ws": "^8.0.0"
    },
    "peerDependencies": {
      "@adiwajshing/keyed-db": "^0.2.4",
      "jimp": "^0.16.1",
      "link-preview-js": "^2.1.13",
      "qrcode-terminal": "^0.12.0",
      "sharp": "^0.30.5"
    },
    "peerDependenciesMeta": {
      "@adiwajshing/keyed-db": {
        "optional": true
      },
      "jimp": {
        "optional": true
      },
      "qrcode-terminal": {
        "optional": true
      },
      "sharp": {
        "optional": true
      },
      "link-preview-js": {
        "optional": true
      }
    },
    "files": [
      "lib/*",
      "WAProto/*",
      "WASignalGroup/*.js"
    ],
    "devDependencies": {
      "@adiwajshing/eslint-config": "git+https://github.com/adiwajshing/eslint-config",
      "@adiwajshing/keyed-db": "^0.2.4",
      "@types/got": "^9.6.11",
      "@types/jest": "^27.5.1",
      "@types/node": "^16.0.0",
      "@types/sharp": "^0.29.4",
      "@types/ws": "^8.0.0",
      "eslint": "^8.0.0",
      "jest": "^27.0.6",
      "jimp": "^0.16.1",
      "link-preview-js": "^2.1.13",
      "qrcode-terminal": "^0.12.0",
      "sharp": "^0.30.5",
      "ts-jest": "^27.0.3",
      "ts-node": "^10.8.1",
      "typedoc": "^0.22.0",
      "typescript": "^4.0.0"
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-@adiwajshing-baileys-4.4.0-6c39c74a29324d22aec67ddbfda890a8e5d85e37-integrity/node_modules/@adiwajshing/baileys/package.json",
    "readmeFilename": "README.md",
    "readme": "# Baileys - Typescript/Javascript WhatsApp Web API\n \n Baileys does not require Selenium or any other browser to be interface with WhatsApp Web, it does so directly using a **WebSocket**. Not running Selenium or Chromimum saves you like **half a gig** of ram :/ \n\n Baileys supports interacting with the multi-device & web versions of WhatsApp.\n\n Thank you to [@pokearaujo](https://github.com/pokearaujo/multidevice) for writing his observations on the workings of WhatsApp Multi-Device. Also, thank you to [@Sigalor](https://github.com/sigalor/whatsapp-web-reveng) for writing his observations on the workings of WhatsApp Web and thanks to [@Rhymen](https://github.com/Rhymen/go-whatsapp/) for the __go__ implementation.\n\n Baileys is type-safe, extensible and simple to use. If you require more functionality than provided, it's super easy to write an extension. More on this [here](#WritingCustomFunctionality).\n \n If you're interested in building a WhatsApp bot, you may wanna check out [WhatsAppInfoBot](https://github.com/adiwajshing/WhatsappInfoBot) and an actual bot built with it, [Messcat](https://github.com/ashokatechmin/Messcat).\n \n **Read the docs [here](https://adiwajshing.github.io/Baileys)**\n **Join the Discord [here](https://discord.gg/WeJM5FP9GG)**\n\n## Example\n\nDo check out & run [example.ts](https://github.com/adiwajshing/Baileys/blob/master/Example/example.ts) to see an example usage of the library.\nThe script covers most common use cases.\nTo run the example script, download or clone the repo and then type the following in a terminal:\n1. ``` cd path/to/Baileys ```\n2. ``` yarn ```\n3. \n    - ``` yarn example ``` for the multi-device edition\n    - ``` yarn example:legacy ``` for the legacy web edition\n\n## Install\n\nUse the stable version:\n```\nyarn add @adiwajshing/baileys\n```\n\nUse the edge version (no guarantee of stability, but latest fixes + features)\n```\nyarn add github:adiwajshing/baileys\n```\n\nThen import your code using:\n``` ts \n// for multi-device\nimport makeWASocket from '@adiwajshing/baileys'\n// for legacy web\nimport {makeWALegacySocket} from '@adiwajshing/baileys'\n```\n\n## Unit Tests\n\nTODO\n\n## Connecting\n\n``` ts\nimport makeWASocket, { DisconnectReason } from '@adiwajshing/baileys'\nimport { Boom } from '@hapi/boom'\n\nasync function connectToWhatsApp () {\n    const sock = makeWASocket({\n        // can provide additional config here\n        printQRInTerminal: true\n    })\n    sock.ev.on('connection.update', (update) => {\n        const { connection, lastDisconnect } = update\n        if(connection === 'close') {\n            const shouldReconnect = (lastDisconnect.error as Boom)?.output?.statusCode !== DisconnectReason.loggedOut\n            console.log('connection closed due to ', lastDisconnect.error, ', reconnecting ', shouldReconnect)\n            // reconnect if not logged out\n            if(shouldReconnect) {\n                connectToWhatsApp()\n            }\n        } else if(connection === 'open') {\n            console.log('opened connection')\n        }\n    })\n    sock.ev.on('messages.upsert', m => {\n        console.log(JSON.stringify(m, undefined, 2))\n\n        console.log('replying to', m.messages[0].key.remoteJid)\n        await sock.sendMessage(m.messages[0].key.remoteJid!, { text: 'Hello there!' })\n    })\n}\n// run in main file\nconnectToWhatsApp()\n``` \n\nIf the connection is successful, you will see a QR code printed on your terminal screen, scan it with WhatsApp on your phone and you'll be logged in!\n\n**Note:** install `qrcode-terminal` using `yarn add qrcode-terminal` to auto-print the QR to the terminal.\n\n## Notable Differences Between Baileys v3 & v4\n\n1. Baileys has been written from the ground up to have a more \"functional\" structure. This is done primarily for simplicity & more testability\n2. The Baileys event emitter will emit all events and be used to generate a source of truth for the connected user's account. Access the event emitter using (`sock.ev`)\n3. Baileys no longer maintains an internal state of chats/contacts/messages. You should ideally take this on your own, simply because your state in MD is its own source of truth & there is no one-size-fits-all way to handle the storage for this. However, a simple storage extension has been provided. This also serves as a good demonstration of how to use the Baileys event emitter to construct a source of truth.\n4. A baileys \"socket\" is meant to be a temporary & disposable object -- this is done to maintain simplicity & prevent bugs. I felt the entire Baileys object became too bloated as it supported too many configurations. You're encouraged to write your own implementation to handle missing functionality.\n5. Baileys does not offer an inbuilt reconnect mechanism anymore (though it's super easy to set one up with your own rules, check the example script)\n\n## Configuring the Connection\n\nYou can configure the connection by passing a `SocketConfig` object.\n\nThe entire `SocketConfig` structure is mentioned here with default values:\n``` ts\ntype SocketConfig = {\n    /** provide an auth state object to maintain the auth state */\n    auth: AuthenticationState\n    /** By default true, should history messages be downloaded and processed */\n    downloadHistory: boolean\n    /** transaction capability options for SignalKeyStore */\n    transactionOpts: TransactionCapabilityOptions\n    /** provide a cache to store a user's device list */\n    userDevicesCache?: NodeCache\n    /** marks the client as online whenever the socket successfully connects */\n    markOnlineOnConnect: boolean\n    /**\n     * map to store the retry counts for failed messages;\n     * used to determine whether to retry a message or not */\n    msgRetryCounterMap?: MessageRetryMap\n    /** width for link preview images */\n    linkPreviewImageThumbnailWidth: number\n    /** Should Baileys ask the phone for full history, will be received async */\n    syncFullHistory: boolean\n    /**\n     * fetch a message from your store\n     * implement this so that messages failed to send (solves the \"this message can take a while\" issue) can be retried\n     * */\n    getMessage: (key: proto.IMessageKey) => Promise<proto.IMessage | undefined>\n}\n```\n\n### Emulating the Desktop app instead of the web\n\n1. Baileys, by default, emulates a chrome web session\n2. If you'd like to emulate a desktop connection (and receive more message history), add this to your Socket config:\n    ``` ts\n    const conn = makeWASocket({\n        ...otherOpts,\n        // can use Windows, Ubuntu here too\n        browser: Browsers.macOS('Desktop'),\n        syncFullHistory: true\n    })\n    ```\n\n## Saving & Restoring Sessions\n\nYou obviously don't want to keep scanning the QR code every time you want to connect. \n\nSo, you can load the credentials to log back in:\n``` ts\nimport makeWASocket, { BufferJSON, useMultiFileAuthState } from '@adiwajshing/baileys'\nimport * as fs from 'fs'\n\n// utility function to help save the auth state in a single folder\n// this function serves as a good guide to help write auth & key states for SQL/no-SQL databases, which I would recommend in any production grade system\nconst { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys')\n// will use the given state to connect\n// so if valid credentials are available -- it'll connect without QR\nconst conn = makeWASocket({ auth: state }) \n// this will be called as soon as the credentials are updated\nconn.ev.on ('creds.update', saveCreds)\n```\n\n**Note:** When a message is received/sent, due to signal sessions needing updating, the auth keys (`authState.keys`) will update. Whenever that happens, you must save the updated keys (`authState.keys.set()` is called). Not doing so will prevent your messages from reaching the recipient & cause other unexpected consequences. The `useMultiFileAuthState` function automatically takes care of that, but for any other serious implementation -- you will need to be very careful with the key state management.\n\n## Listening to Connection Updates\n\nBaileys now fires the `connection.update` event to let you know something has updated in the connection. This data has the following structure:\n``` ts\ntype ConnectionState = {\n\t/** connection is now open, connecting or closed */\n\tconnection: WAConnectionState\n\t/** the error that caused the connection to close */\n\tlastDisconnect?: {\n\t\terror: Error\n\t\tdate: Date\n\t}\n\t/** is this a new login */\n\tisNewLogin?: boolean\n\t/** the current QR code */\n\tqr?: string\n\t/** has the device received all pending notifications while it was offline */\n\treceivedPendingNotifications?: boolean \n}\n```\n\n**Note:** this also offers any updates to the QR\n\n## Handling Events\n\nBaileys uses the EventEmitter syntax for events. \nThey're all nicely typed up, so you shouldn't have any issues with an Intellisense editor like VS Code.\n\nThe events are typed up in a type map, as mentioned here:\n\n``` ts\n\nexport type BaileysEventMap<T> = {\n    /** connection state has been updated -- WS closed, opened, connecting etc. */\n\t'connection.update': Partial<ConnectionState>\n    /** credentials updated -- some metadata, keys or something */\n    'creds.update': Partial<T>\n    /** set chats (history sync), chats are reverse chronologically sorted */\n    'chats.set': { chats: Chat[], isLatest: boolean }\n    /** set messages (history sync), messages are reverse chronologically sorted */\n    'messages.set': { messages: WAMessage[], isLatest: boolean }\n    /** set contacts (history sync) */\n    'contacts.set': { contacts: Contact[], isLatest: boolean }\n    /** upsert chats */\n    'chats.upsert': Chat[]\n    /** update the given chats */\n    'chats.update': Partial<Chat>[]\n    /** delete chats with given ID */\n    'chats.delete': string[]\n    /** presence of contact in a chat updated */\n    'presence.update': { id: string, presences: { [participant: string]: PresenceData } }\n\n    'contacts.upsert': Contact[]\n    'contacts.update': Partial<Contact>[]\n\n    'messages.delete': { keys: WAMessageKey[] } | { jid: string, all: true }\n    'messages.update': WAMessageUpdate[]\n    'messages.media-update': { key: WAMessageKey, media?: { ciphertext: Uint8Array, iv: Uint8Array }, error?: Boom }[]\n    /**\n     * add/update the given messages. If they were received while the connection was online,\n     * the update will have type: \"notify\"\n     *  */\n    'messages.upsert': { messages: WAMessage[], type: MessageUpsertType }\n    /** message was reacted to. If reaction was removed -- then \"reaction.text\" will be falsey */\n    'messages.reaction': { key: WAMessageKey, reaction: proto.IReaction }[]\n\n    'message-receipt.update': MessageUserReceiptUpdate[]\n\n    'groups.upsert': GroupMetadata[]\n    'groups.update': Partial<GroupMetadata>[]\n    /** apply an action to participants in a group */\n    'group-participants.update': { id: string, participants: string[], action: ParticipantAction }\n\n    'blocklist.set': { blocklist: string[] }\n    'blocklist.update': { blocklist: string[], type: 'add' | 'remove' }\n    /** Receive an update on a call, including when the call was received, rejected, accepted */\n    'call': WACallEvent[]\n}\n```\n\nYou can listen to these events like this:\n``` ts\n\nconst sock = makeWASocket()\nsock.ev.on('messages.upsert', ({ messages }) => {\n    console.log('got messages', messages)\n})\n\n```\n\n## Implementing a Data Store\n\nBaileys does not come with a defacto storage for chats, contacts, or messages. However, a simple in-memory implementation has been provided. The store listens for chat updates, new messages, message updates, etc., to always have an up-to-date version of the data.\n\nIt can be used as follows:\n\n``` ts\nimport makeWASocket, { makeInMemoryStore } from '@adiwajshing/baileys'\n// the store maintains the data of the WA connection in memory\n// can be written out to a file & read from it\nconst store = makeInMemoryStore({ })\n// can be read from a file\nstore.readFromFile('./baileys_store.json')\n// saves the state to a file every 10s\nsetInterval(() => {\n    store.writeToFile('./baileys_store.json')\n}, 10_000)\n\nconst sock = makeWASocket({ })\n// will listen from this socket\n// the store can listen from a new socket once the current socket outlives its lifetime\nstore.bind(sock.ev)\n\nsock.ev.on('chats.set', () => {\n    // can use \"store.chats\" however you want, even after the socket dies out\n    // \"chats\" => a KeyedDB instance\n    console.log('got chats', store.chats.all())\n})\n\nsock.ev.on('contacts.set', () => {\n    console.log('got contacts', Object.values(store.contacts))\n})\n\n```\n\nThe store also provides some simple functions such as `loadMessages` that utilize the store to speed up data retrieval.\n\n**Note:** I highly recommend building your own data store especially for MD connections, as storing someone's entire chat history in memory is a terrible waste of RAM.\n\n## Using the Legacy Version\n\nThe API for the legacy and MD versions has been made as similar as possible so you can switch between them seamlessly.\n\nExample on using the eg. version:\n``` ts\nimport P from \"pino\"\nimport { Boom } from \"@hapi/boom\"\nimport { makeWALegacySocket } from '@adiwajshing/baileys'\n\n// store can be used with legacy version as well\nconst store = makeInMemoryStore({ logger: P().child({ level: 'debug', stream: 'store' }) })\n\nconst sock = makeWALegacySocket({\n    logger: P({ level: 'debug' }),\n    printQRInTerminal: true,\n    auth: state\n})\n// bind to the socket\nstore.bind(sock.ev)\n```\n\nIf you need a type representing either the legacy or MD version:\n``` ts\n// this type can have any of the socket types underneath\nimport { AnyWASocket } from '@adiwajshing/baileys'\n```\n\n## Sending Messages\n\n**Send all types of messages with a single function:**\n\n### Non-Media Messages\n\n``` ts\nimport { MessageType, MessageOptions, Mimetype } from '@adiwajshing/baileys'\n\nconst id = 'abcd@s.whatsapp.net' // the WhatsApp ID \n// send a simple text!\nconst sentMsg  = await sock.sendMessage(id, { text: 'oh hello there' })\n// send a reply messagge\nconst sentMsg  = await sock.sendMessage(id, { text: 'oh hello there' }, { quoted: message })\n// send a mentions message\nconst sentMsg  = await sock.sendMessage(id, { text: '@12345678901', mentions: ['12345678901@s.whatsapp.net'] })\n// send a location!\nconst sentMsg  = await sock.sendMessage(\n    id, \n    { location: { degreesLatitude: 24.121231, degreesLongitude: 55.1121221 } }\n)\n// send a contact!\nconst vcard = 'BEGIN:VCARD\\n' // metadata of the contact card\n            + 'VERSION:3.0\\n' \n            + 'FN:Jeff Singh\\n' // full name\n            + 'ORG:Ashoka Uni;\\n' // the organization of the contact\n            + 'TEL;type=CELL;type=VOICE;waid=911234567890:+91 12345 67890\\n' // WhatsApp ID + phone number\n            + 'END:VCARD'\nconst sentMsg  = await sock.sendMessage(\n    id,\n    { \n        contacts: { \n            displayName: 'Jeff', \n            contacts: [{ vcard }] \n        }\n    }\n)\n\n// send a buttons message!\nconst buttons = [\n  {buttonId: 'id1', buttonText: {displayText: 'Button 1'}, type: 1},\n  {buttonId: 'id2', buttonText: {displayText: 'Button 2'}, type: 1},\n  {buttonId: 'id3', buttonText: {displayText: 'Button 3'}, type: 1}\n]\n\nconst buttonMessage = {\n    text: \"Hi it's button message\",\n    footer: 'Hello World',\n    buttons: buttons,\n    headerType: 1\n}\n\nconst sendMsg = await sock.sendMessage(id, buttonMessage)\n\n//send a template message!\nconst templateButtons = [\n    {index: 1, urlButton: {displayText: 'â­ Star Baileys on GitHub!', url: 'https://github.com/adiwajshing/Baileys'}},\n    {index: 2, callButton: {displayText: 'Call me!', phoneNumber: '+1 (234) 5678-901'}},\n    {index: 3, quickReplyButton: {displayText: 'This is a reply, just like normal buttons!', id: 'id-like-buttons-message'}},\n]\n\nconst templateMessage = {\n    text: \"Hi it's a template message\",\n    footer: 'Hello World',\n    templateButtons: templateButtons\n}\n\nconst sendMsg = await sock.sendMessage(id, templateMessage)\n\n// send a list message!\nconst sections = [\n    {\n\ttitle: \"Section 1\",\n\trows: [\n\t    {title: \"Option 1\", rowId: \"option1\"},\n\t    {title: \"Option 2\", rowId: \"option2\", description: \"This is a description\"}\n\t]\n    },\n   {\n\ttitle: \"Section 2\",\n\trows: [\n\t    {title: \"Option 3\", rowId: \"option3\"},\n\t    {title: \"Option 4\", rowId: \"option4\", description: \"This is a description V2\"}\n\t]\n    },\n]\n\nconst listMessage = {\n  text: \"This is a list\",\n  footer: \"nice footer, link: https://google.com\",\n  title: \"Amazing boldfaced list title\",\n  buttonText: \"Required, text on the button to view the list\",\n  sections\n}\n\nconst sendMsg = await sock.sendMessage(id, listMessage)\n\nconst reactionMessage = {\n    react: {\n        text: \"ðŸ’–\", // use an empty string to remove the reaction\n        key: message.key\n    }\n}\n\nconst sendMsg = await sock.sendMessage(id, reactionMessage)\n```\n\n### Sending messages with link previews\n\n1. By default, WA MD does not have link generation when sent from the web\n2. Baileys has a function to generate the content for these link previews\n3. To enable this function's usage, add `link-preview-js` as a dependency to your project with `yarn add link-preview-js`\n4. Send a link:\n``` ts\n// send a link\nconst sentMsg  = await sock.sendMessage(id, { text: 'Hi, this was sent using https://github.com/adiwajshing/baileys' })\n```\n\n### Media Messages\n\nSending media (video, stickers, images) is easier & more efficient than ever. \n- You can specify a buffer, a local url or even a remote url.\n- When specifying a media url, Baileys never loads the entire buffer into memory; it even encrypts the media as a readable stream.\n\n``` ts\nimport { MessageType, MessageOptions, Mimetype } from '@adiwajshing/baileys'\n// Sending gifs\nawait sock.sendMessage(\n    id, \n    { \n        video: fs.readFileSync(\"Media/ma_gif.mp4\"), \n        caption: \"hello!\",\n        gifPlayback: true\n    }\n)\n\nawait sock.sendMessage(\n    id, \n    { \n        video: \"./Media/ma_gif.mp4\", \n        caption: \"hello!\",\n        gifPlayback: true\n    }\n)\n\n// send an audio file\nawait sock.sendMessage(\n    id, \n    { audio: { url: \"./Media/audio.mp3\" }, mimetype: 'audio/mp4' }\n    { url: \"Media/audio.mp3\" }, // can send mp3, mp4, & ogg\n)\n\n// send a buttons message with image header!\nconst buttons = [\n  {buttonId: 'id1', buttonText: {displayText: 'Button 1'}, type: 1},\n  {buttonId: 'id2', buttonText: {displayText: 'Button 2'}, type: 1},\n  {buttonId: 'id3', buttonText: {displayText: 'Button 3'}, type: 1}\n]\n\nconst buttonMessage = {\n    image: {url: 'https://example.com/image.jpeg'},\n    caption: \"Hi it's button message\",\n    footer: 'Hello World',\n    buttons: buttons,\n    headerType: 4\n}\n\nconst sendMsg = await sock.sendMessage(id, buttonMessage)\n\n//send a template message with an image **attached**!\nconst templateButtons = [\n  {index: 1, urlButton: {displayText: 'â­ Star Baileys on GitHub!', url: 'https://github.com/adiwajshing/Baileys'}},\n  {index: 2, callButton: {displayText: 'Call me!', phoneNumber: '+1 (234) 5678-901'}},\n  {index: 3, quickReplyButton: {displayText: 'This is a reply, just like normal buttons!', id: 'id-like-buttons-message'}},\n]\n\nconst buttonMessage = {\n    text: \"Hi it's a template message\",\n    footer: 'Hello World',\n    templateButtons: templateButtons,\n    image: {url: 'https://example.com/image.jpeg'}\n}\n\nconst sendMsg = await sock.sendMessage(id, templateMessage)\n```\n\n### Notes\n\n- `id` is the WhatsApp ID of the person or group you're sending the message to. \n    - It must be in the format ```[country code][phone number]@s.whatsapp.net```\n\t    - Example for people: ```+19999999999@s.whatsapp.net```. \n\t    - For groups, it must be in the format ``` 123456789-123345@g.us ```. \n    - For broadcast lists, it's `[timestamp of creation]@broadcast`.\n    - For stories, the ID is `status@broadcast`.\n- For media messages, the thumbnail can be generated automatically for images & stickers provided you add `jimp` or `sharp` as a dependency in your project using `yarn add jimp` or `yarn add sharp`. Thumbnails for videos can also be generated automatically, though, you need to have `ffmpeg` installed on your system.\n- **MiscGenerationOptions**: some extra info about the message. It can have the following __optional__ values:\n    ``` ts\n    const info: MessageOptions = {\n        quoted: quotedMessage, // the message you want to quote\n        contextInfo: { forwardingScore: 2, isForwarded: true }, // some random context info (can show a forwarded message with this too)\n        timestamp: Date(), // optional, if you want to manually set the timestamp of the message\n        caption: \"hello there!\", // (for media messages) the caption to send with the media (cannot be sent with stickers though)\n        jpegThumbnail: \"23GD#4/==\", /*  (for location & media messages) has to be a base 64 encoded JPEG if you want to send a custom thumb, \n                                    or set to null if you don't want to send a thumbnail.\n                                    Do not enter this field if you want to automatically generate a thumb\n                                */\n        mimetype: Mimetype.pdf, /* (for media messages) specify the type of media (optional for all media types except documents),\n                                    import {Mimetype} from '@adiwajshing/baileys'\n                                */\n        fileName: 'somefile.pdf', // (for media messages) file name for the media\n        /* will send audio messages as voice notes, if set to true */\n        ptt: true,\n        /** Should it send as a disappearing messages. \n         * By default 'chat' -- which follows the setting of the chat */\n        sendEphemeral: 'chat'\n    }\n    ```\n## Forwarding Messages\n\n``` ts\nconst msg = getMessageFromStore('455@s.whatsapp.net', 'HSJHJWH7323HSJSJ') // implement this on your end\nawait sock.sendMessage('1234@s.whatsapp.net', { forward: msg }) // WA forward the message!\n```\n\n## Reading Messages\n\nA set of message keys must be explicitly marked read now. \nIn multi-device, you cannot mark an entire \"chat\" read as it were with Baileys Web.\nThis means you have to keep track of unread messages.\n\n``` ts\nconst key = {\n    remoteJid: '1234-123@g.us',\n    id: 'AHASHH123123AHGA', // id of the message you want to read\n    participant: '912121232@s.whatsapp.net' // the ID of the user that sent the  message (undefined for individual chats)\n}\n// pass to readMessages function\n// can pass multiple keys to read multiple messages as well\nawait sock.readMessages([key])\n```\n\nThe message ID is the unique identifier of the message that you are marking as read. \nOn a `WAMessage`, the `messageID` can be accessed using ```messageID = message.key.id```.\n\n## Update Presence\n\n``` ts\nawait sock.sendPresenceUpdate('available', id) \n\n```\nThis lets the person/group with ``` id ``` know whether you're online, offline, typing etc. \n\n``` presence ``` can be one of the following:\n``` ts\ntype WAPresence = 'unavailable' | 'available' | 'composing' | 'recording' | 'paused'\n```\n\nThe presence expires after about 10 seconds.\n\n**Note:** In the multi-device version of WhatsApp -- if a desktop client is active, WA doesn't send push notifications to the device. If you would like to receive said notifications -- mark your Baileys client offline using `sock.sendPresenceUpdate('unavailable')`\n\n## Downloading Media Messages\n\nIf you want to save the media you received\n``` ts\nimport { writeFile } from 'fs/promises'\nimport { downloadMediaMessage } from '@adiwajshing/baileys'\n\nsock.ev.on('messages.upsert', async ({ messages }) => {\n    const m = messages[0]\n\n    if (!m.message) return // if there is no text or media message\n    const messageType = Object.keys (m.message)[0]// get what type of message it is -- text, image, video\n    // if the message is an image\n    if (messageType === 'imageMessage') {\n        // download the message\n        const buffer = await downloadMediaMessage(\n            m,\n            'buffer',\n            { },\n            { \n                logger,\n                // pass this so that baileys can request a reupload of media\n                // that has been deleted\n                reuploadRequest: sock.updateMediaMessage\n            }\n        )\n        // save to file\n        await writeFile('./my-download.jpeg', buffer)\n    }\n}\n```\n\n**Note:** WhatsApp automatically removes old media from their servers. For the device to access said media -- a re-upload is required by another device that has it. This can be accomplished using: \n``` ts\nconst updatedMediaMsg = await sock.updateMediaMessage(msg)\n```\n\n## Deleting Messages\n\n``` ts\nconst jid = '1234@s.whatsapp.net' // can also be a group\nconst response = await sock.sendMessage(jid, { text: 'hello!' }) // send a message\n// sends a message to delete the given message\n// this deletes the message for everyone\nawait sock.sendMessage(jid, { delete: response.key })\n```\n\n**Note:** deleting for oneself is supported via `chatModify` (next section)\n\n## Modifying Chats\n\nWA uses an encrypted form of communication to send chat/app updates. This has been implemented mostly and you can send the following updates:\n\n- Archive a chat\n  ``` ts\n  const lastMsgInChat = await getLastMessageInChat('123456@s.whatsapp.net') // implement this on your end\n  await sock.chatModify({ archive: true, lastMessages: [lastMsgInChat] }, '123456@s.whatsapp.net')\n  ```\n- Mute/unmute a chat\n  ``` ts\n  // mute for 8 hours\n  await sock.chatModify({ mute: 8*60*60*1000 }, '123456@s.whatsapp.net', [])\n  // unmute\n  await sock.chatModify({ mute: null }, '123456@s.whatsapp.net', [])\n  ```\n- Mark a chat read/unread\n  ``` ts\n  const lastMsgInChat = await getLastMessageInChat('123456@s.whatsapp.net') // implement this on your end\n  // mark it unread\n  await sock.chatModify({ markRead: false, lastMessages: [lastMsgInChat] }, '123456@s.whatsapp.net')\n  ```\n\n- Delete a message for me\n  ``` ts\n  await sock.chatModify(\n    { clear: { messages: [{ id: 'ATWYHDNNWU81732J', fromMe: true, timestamp: \"1654823909\" }] } }, \n    '123456@s.whatsapp.net', \n    []\n    )\n\n  ```\n\n**Note:** if you mess up one of your updates, WA can log you out of all your devices and you'll have to log in again.\n\n## Disappearing Messages\n\n``` ts\nconst jid = '1234@s.whatsapp.net' // can also be a group\n// turn on disappearing messages\nawait sock.sendMessage(\n    jid, \n    // this is 1 week in seconds -- how long you want messages to appear for\n    { disappearingMessagesInChat: WA_DEFAULT_EPHEMERAL }\n)\n// will send as a disappearing message\nawait sock.sendMessage(jid, { text: 'hello' }, { ephemeralExpiration: WA_DEFAULT_EPHEMERAL })\n// turn off disappearing messages\nawait sock.sendMessage(\n    jid, \n    { disappearingMessagesInChat: false }\n)\n\n```\n\n## Misc\n\n- To check if a given ID is on WhatsApp\n    ``` ts\n    const id = '123456'\n    const [result] = await sock.onWhatsApp(id)\n    if (result.exists) console.log (`${id} exists on WhatsApp, as jid: ${result.jid}`)\n    ```\n- To query chat history on a group or with someone\n    TODO, if possible\n- To get the status of some person\n    ``` ts\n    const status = await sock.fetchStatus(\"xyz@s.whatsapp.net\")\n    console.log(\"status: \" + status)\n    ```\n- To change your profile status\n    ``` ts\n    const status = 'Hello World!'\n    await sock.updateProfileStatus(status)\n    ```\n- To change your profile name\n    ``` ts\n    const name = 'My name'\n    await sock.updateProfileName(name)\n    ```\n- To get the display picture of some person/group\n    ``` ts\n    // for low res picture\n    const ppUrl = await sock.profilePictureUrl(\"xyz@g.us\")\n    console.log(\"download profile picture from: \" + ppUrl)\n    // for high res picture\n    const ppUrl = await sock.profilePictureUrl(\"xyz@g.us\", 'image')\n    ```\n- To change your display picture or a group's\n    ``` ts\n    const jid = '111234567890-1594482450@g.us' // can be your own too\n    await sock.updateProfilePicture(jid, { url: './new-profile-picture.jpeg' })\n    ```\n- To get someone's presence (if they're typing or online)\n    ``` ts\n    // the presence update is fetched and called here\n    sock.ev.on('presence-update', json => console.log(json))\n    // request updates for a chat\n    await sock.presenceSubscribe(\"xyz@s.whatsapp.net\") \n    ```\n- To block or unblock user\n    ``` ts\n    await sock.updateBlockStatus(\"xyz@s.whatsapp.net\", \"block\") // Block user\n    await sock.updateBlockStatus(\"xyz@s.whatsapp.net\", \"unblock\") // Unblock user\n    ```\n- To get a business profile, such as description or category\n    ```ts\n    const profile = await sock.getBusinessProfile(\"xyz@s.whatsapp.net\")\n    console.log(\"business description: \" + profile.description + \", category: \" + profile.category)\n    ```\nOf course, replace ``` xyz ``` with an actual ID. \n\n## Groups\n- To create a group\n    ``` ts\n    // title & participants\n    const group = await sock.groupCreate(\"My Fab Group\", [\"1234@s.whatsapp.net\", \"4564@s.whatsapp.net\"])\n    console.log (\"created group with id: \" + group.gid)\n    sock.sendMessage(group.id, { text: 'hello there' }) // say hello to everyone on the group\n    ```\n- To add/remove people to a group or demote/promote people\n    ``` ts\n    // id & people to add to the group (will throw error if it fails)\n    const response = await sock.groupParticipantsUpdate(\n        \"abcd-xyz@g.us\", \n        [\"abcd@s.whatsapp.net\", \"efgh@s.whatsapp.net\"],\n        \"add\" // replace this parameter with \"remove\", \"demote\" or \"promote\"\n    )\n    ```\n- To change the group's subject\n    ``` ts\n    await sock.groupUpdateSubject(\"abcd-xyz@g.us\", \"New Subject!\")\n    ```\n- To change the group's description\n    ``` ts\n    await sock.groupUpdateDescription(\"abcd-xyz@g.us\", \"New Description!\")\n    ```\n- To change group settings\n    ``` ts\n    // only allow admins to send messages\n    await sock.groupSettingUpdate(\"abcd-xyz@g.us\", 'announcement')\n    // allow everyone to send messages\n    await sock.groupSettingUpdate(\"abcd-xyz@g.us\", 'not_announcement')\n    // allow everyone to modify the group's settings -- like display picture etc.\n    await sock.groupSettingUpdate(\"abcd-xyz@g.us\", 'unlocked')\n    // only allow admins to modify the group's settings\n    await sock.groupSettingUpdate(\"abcd-xyz@g.us\", 'locked')\n    ```\n- To leave a group\n    ``` ts\n    await sock.groupLeave(\"abcd-xyz@g.us\") // (will throw error if it fails)\n    ```\n- To get the invite code for a group\n    ``` ts\n    const code = await sock.groupInviteCode(\"abcd-xyz@g.us\")\n    console.log(\"group code: \" + code)\n    ```\n- To revoke the invite code in a group\n    ```ts\n    const code = await sock.groupRevokeInvite(\"abcd-xyz@g.us\")\n    console.log(\"New group code: \" + code)\n    ```\n- To query the metadata of a group\n    ``` ts\n    const metadata = await sock.groupMetadata(\"abcd-xyz@g.us\") \n    console.log(metadata.id + \", title: \" + metadata.subject + \", description: \" + metadata.desc)\n    ```\n- To join the group using the invitation code\n    ``` ts\n    const response = await sock.groupAcceptInvite(\"xxx\")\n    console.log(\"joined to: \" + response)\n    ```\n    Of course, replace ``` xxx ``` with invitation code.\n- To get group info by invite code\n    ```ts\n    const response = await sock.groupGetInviteInfo(\"xxx\")\n    console.log(\"group information: \" + response)\n    ```\n- To join the group using groupInviteMessage\n    ``` ts\n    const response = await sock.groupAcceptInviteV4(\"abcd@s.whatsapp.net\", groupInviteMessage)\n    console.log(\"joined to: \" + response)\n    ```\n  Of course, replace ``` xxx ``` with invitation code.\n  \n## Broadcast Lists & Stories\n\n**Note:** messages currently cannot be sent to broadcast lists from the MD version.\n\n- You can send messages to broadcast lists the same way you send messages to groups & individual chats.\n- Right now, WA Web does not support creating broadcast lists, but you can still delete them.\n- Broadcast IDs are in the format `12345678@broadcast`\n- To query a broadcast list's recipients & name:\n    ``` ts\n    const bList = await sock.getBroadcastListInfo(\"1234@broadcast\")\n    console.log (`list name: ${bList.name}, recps: ${bList.recipients}`)\n    ```\n\n## Writing Custom Functionality\nBaileys is written with custom functionality in mind. Instead of forking the project & re-writing the internals, you can simply write your own extensions.\n\nFirst, enable the logging of unhandled messages from WhatsApp by setting:\n``` ts\nconst sock = makeWASocket({\n    logger: P({ level: 'debug' }),\n})\n```\nThis will enable you to see all sorts of messages WhatsApp sends in the console. \n\nSome examples:\n\n1. Functionality to track the battery percentage of your phone.\n    You enable logging and you'll see a message about your battery pop up in the console: \n    ```{\"level\":10,\"fromMe\":false,\"frame\":{\"tag\":\"ib\",\"attrs\":{\"from\":\"@s.whatsapp.net\"},\"content\":[{\"tag\":\"edge_routing\",\"attrs\":{},\"content\":[{\"tag\":\"routing_info\",\"attrs\":{},\"content\":{\"type\":\"Buffer\",\"data\":[8,2,8,5]}}]}]},\"msg\":\"communication\"} ``` \n    \n   The \"frame\" is what the message received is, it has three components:\n   - `tag` -- what this frame is about (eg. message will have \"message\")\n   - `attrs` -- a string key-value pair with some metadata (contains ID of the message usually)\n   - `content` -- the actual data (eg. a message node will have the actual message content in it)\n   - read more about this format [here](/src/WABinary/readme.md)\n\n    You can register a callback for an event using the following:\n    ``` ts\n    // for any message with tag 'edge_routing'\n    sock.ws.on(`CB:edge_routing`, (node: BinaryNode) => { })\n    // for any message with tag 'edge_routing' and id attribute = abcd\n    sock.ws.on(`CB:edge_routing,id:abcd`, (node: BinaryNode) => { })\n    // for any message with tag 'edge_routing', id attribute = abcd & first content node routing_info\n    sock.ws.on(`CB:edge_routing,id:abcd,routing_info`, (node: BinaryNode) => { })\n    ```\n\n### Note\n\n This library was originally a project for **CS-2362 at Ashoka University** and is in no way affiliated with WhatsApp. Use at your own discretion. Do not spam people with this.\n\n Also, this repo is now licenced under GPL 3 since it uses [libsignal-node](https://git.questbook.io/backend/service-coderunner/-/merge_requests/1)\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@adiwajshing/baileys/-/baileys-4.4.0.tgz#6c39c74a29324d22aec67ddbfda890a8e5d85e37",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@adiwajshing/baileys/-/baileys-4.4.0.tgz",
    "hash": "6c39c74a29324d22aec67ddbfda890a8e5d85e37",
    "integrity": "sha512-5gEnkJBgraLL0USzndxto8ofYhWyMFZVkpZ4rD1nPqrjBjGMt+k+YDpllpFpOfA0yxWZb6nPrr04ikQv++dz2Q==",
    "registry": "npm",
    "packageName": "@adiwajshing/baileys",
    "cacheIntegrity": "sha512-5gEnkJBgraLL0USzndxto8ofYhWyMFZVkpZ4rD1nPqrjBjGMt+k+YDpllpFpOfA0yxWZb6nPrr04ikQv++dz2Q== sha1-bDnHSikyTSKuxn3b/aiQqOXYXjc="
  },
  "registry": "npm",
  "hash": "6c39c74a29324d22aec67ddbfda890a8e5d85e37"
}