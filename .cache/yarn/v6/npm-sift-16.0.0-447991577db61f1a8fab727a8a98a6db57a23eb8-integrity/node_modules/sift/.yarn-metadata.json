{
  "manifest": {
    "name": "sift",
    "description": "MongoDB query filtering in JavaScript",
    "version": "16.0.0",
    "repository": {
      "type": "git",
      "url": "https://github.com/crcn/sift.js.git"
    },
    "sideEffects": false,
    "author": {
      "name": "Craig Condon",
      "email": "craig.j.condon@gmail.com"
    },
    "license": "MIT",
    "engines": {},
    "typings": "./index.d.ts",
    "husky": {
      "hooks": {
        "pre-commit": "pretty-quick --staged"
      }
    },
    "devDependencies": {
      "@rollup/plugin-replace": "^2.3.2",
      "@rollup/plugin-typescript": "8.2.1",
      "@types/node": "^13.7.0",
      "bson": "^4.0.3",
      "eval": "^0.1.4",
      "husky": "^1.2.1",
      "immutable": "^3.7.6",
      "mocha": "8.3.2",
      "mongodb": "^3.6.6",
      "prettier": "1.15.3",
      "pretty-quick": "^1.11.1",
      "rimraf": "^3.0.2",
      "rollup": "^2.7.2",
      "rollup-plugin-terser": "^7.0.2",
      "tslib": "2.2.0",
      "typescript": "4.2.4"
    },
    "main": "./index.js",
    "module": "./es5m/index.js",
    "es2015": "./es/index.js",
    "scripts": {
      "clean": "rimraf lib es5m es",
      "prebuild": "npm run clean && npm run build:types",
      "build": "rollup -c",
      "build:types": "tsc -p tsconfig.json --emitDeclarationOnly --outDir lib",
      "test": "npm run test:spec && npm run test:types",
      "test:spec": "mocha ./test -R spec",
      "test:types": "cd test && tsc types.ts --noEmit",
      "prepublishOnly": "npm run build && npm run test"
    },
    "files": [
      "es",
      "es5m",
      "lib",
      "src",
      "*.d.ts",
      "*.js.map",
      "index.js",
      "sift.csp.min.js",
      "sift.min.js",
      "MIT-LICENSE.txt"
    ],
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-sift-16.0.0-447991577db61f1a8fab727a8a98a6db57a23eb8-integrity/node_modules/sift/package.json",
    "readmeFilename": "README.md",
    "readme": "**Installation**: `npm install sift`, or `yarn add sift`\n\n## Sift is a tiny library for using MongoDB queries in Javascript\n\n[![Build Status](https://secure.travis-ci.org/crcn/sift.js.png)](https://secure.travis-ci.org/crcn/sift.js)\n\n<!-- [![Coverage Status](https://coveralls.io/repos/crcn/sift.js/badge.svg)](https://coveralls.io/r/crcn/sift.js)  -->\n<!-- [![Join the chat at https://gitter.im/crcn/sift.js](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/crcn/sift.js?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) -->\n\n**For extended documentation, checkout http://docs.mongodb.org/manual/reference/operator/query/**\n\n## Features:\n\n- Supported operators: [\\$in](#in), [\\$nin](#nin), [\\$exists](#exists), [\\$gte](#gte), [\\$gt](#gt), [\\$lte](#lte), [\\$lt](#lt), [\\$eq](#eq), [\\$ne](#ne), [\\$mod](#mod), [\\$all](#all), [\\$and](#and), [\\$or](#or), [\\$nor](#nor), [\\$not](#not), [\\$size](#size), [\\$type](#type), [\\$regex](#regex), [\\$where](#where), [\\$elemMatch](#elemmatch)\n- Regexp searches\n- Supports node.js, and web\n- Custom Operations\n- Tree-shaking (omitting functionality from web app bundles)\n\n## Examples\n\n```javascript\nimport sift from \"sift\";\n\n//intersecting arrays\nconst result1 = [\"hello\", \"sifted\", \"array!\"].filter(\n  sift({ $in: [\"hello\", \"world\"] })\n); //['hello']\n\n//regexp filter\nconst result2 = [\"craig\", \"john\", \"jake\"].filter(sift(/^j/)); //['john','jake']\n\n// function filter\nconst testFilter = sift({\n  //you can also filter against functions\n  name: function(value) {\n    return value.length == 5;\n  }\n});\n\nconst result3 = [\n  {\n    name: \"craig\"\n  },\n  {\n    name: \"john\"\n  },\n  {\n    name: \"jake\"\n  }\n].filter(testFilter); // filtered: [{ name: 'craig' }]\n\n//you can test *single values* against your custom sifter\ntestFilter({ name: \"sarah\" }); //true\ntestFilter({ name: \"tim\" }); //false\n```\n\n## API\n\n### sift(query: MongoQuery, options?: Options): Function\n\nCreates a filter with all of the built-in MongoDB query operations.\n\n- `query` - the filter to use against the target array\n- `options`\n  - `operations` - [custom operations](#custom-operations)\n  - `compare` - compares difference between two values\n\nExample:\n\n```javascript\nimport sift from \"sift\";\n\nconst test = sift({ $gt: 5 }));\n\nconsole.log(test(6)); // true\nconsole.log(test(4)); // false\n\n[3, 4, 5, 6, 7].filter(sift({ $exists: true })); // [6, 7]\n```\n\n### createQueryTester(query: Query, options?: Options): Function\n\nCreates a filter function **without** built-in MongoDB query operations. This is useful\nif you're looking to omit certain operations from application bundles. See [Omitting built-in operations](#omitting-built-in-operations) for more info.\n\n```javascript\nimport { createQueryTester, $eq, $in } from \"sift\";\nconst filter = createQueryTester({ $eq: 5 }, { operations: { $eq, $in } });\n```\n\n### createEqualsOperation(params: any, ownerQuery: Query, options: Options): Operation\n\nUsed for [custom operations](#custom-operations).\n\n```javascript\nimport { createQueryTester, createEqualsOperation, $eq, $in } from \"sift\";\nconst filter = createQueryTester(\n  { $mod: 5 },\n  {\n    operations: {\n      $something(mod, ownerQuery, options) {\n        return createEqualsOperation(\n          value => value % mod === 0,\n          ownerQuery,\n          options\n        );\n      }\n    }\n  }\n);\nfilter(10); // true\nfilter(11); // false\n```\n\n## Supported Operators\n\nSee MongoDB's [advanced queries](http://www.mongodb.org/display/DOCS/Advanced+Queries) for more info.\n\n### \\$in\n\narray value must be _\\$in_ the given query:\n\nIntersecting two arrays:\n\n```javascript\n//filtered: ['Brazil']\n[\"Brazil\", \"Haiti\", \"Peru\", \"Chile\"].filter(\n  sift({ $in: [\"Costa Rica\", \"Brazil\"] })\n);\n```\n\nHere's another example. This acts more like the \\$or operator:\n\n```javascript\n[{ name: \"Craig\", location: \"Brazil\" }].filter(\n  sift({ location: { $in: [\"Costa Rica\", \"Brazil\"] } })\n);\n```\n\n### \\$nin\n\nOpposite of \\$in:\n\n```javascript\n//filtered: ['Haiti','Peru','Chile']\n[\"Brazil\", \"Haiti\", \"Peru\", \"Chile\"].filter(\n  sift({ $nin: [\"Costa Rica\", \"Brazil\"] })\n);\n```\n\n### \\$exists\n\nChecks if whether a value exists:\n\n```javascript\n//filtered: ['Craig','Tim']\nsift({ $exists: true })([\"Craig\", null, \"Tim\"]);\n```\n\nYou can also filter out values that don't exist\n\n```javascript\n//filtered: [{ name: \"Tim\" }]\n[{ name: \"Craig\", city: \"Minneapolis\" }, { name: \"Tim\" }].filter(\n  sift({ city: { $exists: false } })\n);\n```\n\n### \\$gte\n\nChecks if a number is >= value:\n\n```javascript\n//filtered: [2, 3]\n[0, 1, 2, 3].filter(sift({ $gte: 2 }));\n```\n\n### \\$gt\n\nChecks if a number is > value:\n\n```javascript\n//filtered: [3]\n[0, 1, 2, 3].filter(sift({ $gt: 2 }));\n```\n\n### \\$lte\n\nChecks if a number is <= value.\n\n```javascript\n//filtered: [0, 1, 2]\n[0, 1, 2, 3].filter(sift({ $lte: 2 }));\n```\n\n### \\$lt\n\nChecks if number is < value.\n\n```javascript\n//filtered: [0, 1]\n[0, 1, 2, 3].filter(sift({ $lt: 2 }));\n```\n\n### \\$eq\n\nChecks if `query === value`. Note that **\\$eq can be omitted**. For **\\$eq**, and **\\$ne**\n\n```javascript\n//filtered: [{ state: 'MN' }]\n[{ state: \"MN\" }, { state: \"CA\" }, { state: \"WI\" }].filter(\n  sift({ state: { $eq: \"MN\" } })\n);\n```\n\nOr:\n\n```javascript\n//filtered: [{ state: 'MN' }]\n[{ state: \"MN\" }, { state: \"CA\" }, { state: \"WI\" }].filter(\n  sift({ state: \"MN\" })\n);\n```\n\n### \\$ne\n\nChecks if `query !== value`.\n\n```javascript\n//filtered: [{ state: 'CA' }, { state: 'WI'}]\n[{ state: \"MN\" }, { state: \"CA\" }, { state: \"WI\" }].filter(\n  sift({ state: { $ne: \"MN\" } })\n);\n```\n\n### \\$mod\n\nModulus:\n\n```javascript\n//filtered: [300, 600]\n[100, 200, 300, 400, 500, 600].filter(sift({ $mod: [3, 0] }));\n```\n\n### \\$all\n\nvalues must match **everything** in array:\n\n```javascript\n//filtered: [ { tags: ['books','programming','travel' ]} ]\n[\n  { tags: [\"books\", \"programming\", \"travel\"] },\n  { tags: [\"travel\", \"cooking\"] }\n].filter(sift({ tags: { $all: [\"books\", \"programming\"] } }));\n```\n\n### \\$and\n\nability to use an array of expressions. All expressions must test true.\n\n```javascript\n//filtered: [ { name: 'Craig', state: 'MN' }]\n\n[\n  { name: \"Craig\", state: \"MN\" },\n  { name: \"Tim\", state: \"MN\" },\n  { name: \"Joe\", state: \"CA\" }\n].filter(sift({ $and: [{ name: \"Craig\" }, { state: \"MN\" }] }));\n```\n\n### \\$or\n\nOR array of expressions.\n\n```javascript\n//filtered: [ { name: 'Craig', state: 'MN' }, { name: 'Tim', state: 'MN' }]\n[\n  { name: \"Craig\", state: \"MN\" },\n  { name: \"Tim\", state: \"MN\" },\n  { name: \"Joe\", state: \"CA\" }\n].filter(sift({ $or: [{ name: \"Craig\" }, { state: \"MN\" }] }));\n```\n\n### \\$nor\n\nopposite of or:\n\n```javascript\n//filtered: [{ name: 'Joe', state: 'CA' }]\n[\n  { name: \"Craig\", state: \"MN\" },\n  { name: \"Tim\", state: \"MN\" },\n  { name: \"Joe\", state: \"CA\" }\n].filter(sift({ $nor: [{ name: \"Craig\" }, { state: \"MN\" }] }));\n```\n\n### \\$size\n\nMatches an array - must match given size:\n\n```javascript\n//filtered: ['food','cooking']\n[{ tags: [\"food\", \"cooking\"] }, { tags: [\"traveling\"] }].filter(\n  sift({ tags: { $size: 2 } })\n);\n```\n\n### \\$type\n\nMatches a values based on the type\n\n```javascript\n[new Date(), 4342, \"hello world\"].filter(sift({ $type: Date })); //returns single date\n[new Date(), 4342, \"hello world\"].filter(sift({ $type: String })); //returns ['hello world']\n```\n\n### \\$regex\n\nMatches values based on the given regular expression\n\n```javascript\n[\"frank\", \"fred\", \"sam\", \"frost\"].filter(\n  sift({ $regex: /^f/i, $nin: [\"frank\"] })\n); // [\"fred\", \"frost\"]\n[\"frank\", \"fred\", \"sam\", \"frost\"].filter(\n  sift({ $regex: \"^f\", $options: \"i\", $nin: [\"frank\"] })\n); // [\"fred\", \"frost\"]\n```\n\n### \\$where\n\nMatches based on some javascript comparison\n\n```javascript\n[{ name: \"frank\" }, { name: \"joe\" }].filter(\n  sift({ $where: \"this.name === 'frank'\" })\n); // [\"frank\"]\n[{ name: \"frank\" }, { name: \"joe\" }].filter(\n  sift({\n    $where: function() {\n      return this.name === \"frank\";\n    }\n  })\n); // [\"frank\"]\n```\n\n### \\$elemMatch\n\nMatches elements of array\n\n```javascript\nvar bills = [\n  {\n    month: \"july\",\n    casts: [\n      {\n        id: 1,\n        value: 200\n      },\n      {\n        id: 2,\n        value: 1000\n      }\n    ]\n  },\n  {\n    month: \"august\",\n    casts: [\n      {\n        id: 3,\n        value: 1000\n      },\n      {\n        id: 4,\n        value: 4000\n      }\n    ]\n  }\n];\n\nvar result = bills.filter(\n  sift({\n    casts: {\n      $elemMatch: {\n        value: { $gt: 1000 }\n      }\n    }\n  })\n); // {month:'august', casts:[{id:3, value: 1000},{id: 4, value: 4000}]}\n```\n\n### \\$not\n\nNot expression:\n\n```javascript\n[\"craig\", \"tim\", \"jake\"].filter(sift({ $not: { $in: [\"craig\", \"tim\"] } })); //['jake']\n[\"craig\", \"tim\", \"jake\"].filter(sift({ $not: { $size: 5 } })); //['tim','jake']\n```\n\n### Date comparison\n\nMongodb allows you to do date comparisons like so:\n\n```javascript\ndb.collection.find({ createdAt: { $gte: \"2018-03-22T06:00:00Z\" } });\n```\n\nIn Sift, you'll need to specify a Date object:\n\n```javascript\ncollection.find(\n  sift({ createdAt: { $gte: new Date(\"2018-03-22T06:00:00Z\") } })\n);\n```\n\n## Custom behavior\n\nSift works like MongoDB out of the box, but you're also able to modify the behavior to suite your needs.\n\n#### Custom operations\n\nYou can register your own custom operations. Here's an example:\n\n```javascript\nimport sift, { createEqualsOperation } from \"sift\";\n\nvar filter = sift(\n  {\n    $customMod: 2\n  },\n  {\n    operations: {\n      $customMod(params, ownerQuery, options) {\n        return createEqualsOperation(\n          value => value % params !== 0,\n          ownerQuery,\n          options\n        );\n      }\n    }\n  }\n);\n\n[1, 2, 3, 4, 5].filter(filter); // 1, 3, 5\n```\n\n#### Omitting built-in operations\n\nYou can create a filter function that omits the built-in operations like so:\n\n```javascript\nimport { createQueryTester, $in, $all, $nin, $lt } from \"sift\";\nconst test = createQueryTester(\n  {\n    $eq: 10\n  },\n  { operations: { $in, $all, $nin, $lt } }\n);\n\n[1, 2, 3, 4, 10].filter(test);\n```\n\nFor bundlers like `Webpack` and `Rollup`, operations that aren't used are omitted from application bundles via tree-shaking.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/sift/-/sift-16.0.0.tgz#447991577db61f1a8fab727a8a98a6db57a23eb8",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/sift/-/sift-16.0.0.tgz",
    "hash": "447991577db61f1a8fab727a8a98a6db57a23eb8",
    "integrity": "sha512-ILTjdP2Mv9V1kIxWMXeMTIRbOBrqKc4JAXmFMnFq3fKeyQ2Qwa3Dw1ubcye3vR+Y6ofA0b9gNDr/y2t6eUeIzQ==",
    "registry": "npm",
    "packageName": "sift",
    "cacheIntegrity": "sha512-ILTjdP2Mv9V1kIxWMXeMTIRbOBrqKc4JAXmFMnFq3fKeyQ2Qwa3Dw1ubcye3vR+Y6ofA0b9gNDr/y2t6eUeIzQ== sha1-RHmRV322HxqPq3J6ipim21eiPrg="
  },
  "registry": "npm",
  "hash": "447991577db61f1a8fab727a8a98a6db57a23eb8"
}