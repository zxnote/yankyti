{
  "manifest": {
    "name": "typed-function",
    "version": "2.1.0",
    "description": "Type checking for JavaScript functions",
    "author": {
      "name": "Jos de Jong",
      "email": "wjosdejong@gmail.com",
      "url": "https://github.com/josdejong"
    },
    "contributors": [
      {
        "name": "Luke Gumbley",
        "url": "https://github.com/luke-gumbley"
      }
    ],
    "homepage": "https://github.com/josdejong/typed-function",
    "repository": {
      "type": "git",
      "url": "https://github.com/josdejong/typed-function.git"
    },
    "keywords": [
      "typed",
      "function",
      "arguments",
      "compose",
      "types"
    ],
    "dependencies": {},
    "devDependencies": {
      "benchmark": "2.1.4",
      "brace-expansion": "2.0.1",
      "istanbul": "0.4.5",
      "mocha": "8.3.2",
      "pad-right": "0.2.2",
      "uglify-js": "3.13.3"
    },
    "comment": "brace-expansion is installed because an old insecure version is used by one of the dev depencencies (under istanbul)",
    "main": "typed-function.js",
    "scripts": {
      "build": "uglifyjs typed-function.js -o typed-function.min.js -c -m",
      "test": "mocha test --recursive",
      "coverage": "istanbul cover _mocha -- test --recursive; echo \"\nCoverage report is available at ./coverage/lcov-report/index.html\"",
      "prepublishOnly": "npm test && npm run build"
    },
    "engines": {
      "node": ">= 10"
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-typed-function-2.1.0-ded6f8a442ba8749ff3fe75bc41419c8d46ccc3f-integrity/node_modules/typed-function/package.json",
    "readmeFilename": "README.md",
    "readme": "# typed-function\n\n[![Version](https://img.shields.io/npm/v/typed-function.svg)](https://www.npmjs.com/package/typed-function)\n[![Downloads](https://img.shields.io/npm/dm/typed-function.svg)](https://www.npmjs.com/package/typed-function)\n[![Build Status](https://github.com/josdejong/typed-function/workflows/Node.js%20CI/badge.svg)](https://github.com/josdejong/typed-function/actions)\n\nMove type checking logic and type conversions outside of your function in a\nflexible, organized way. Automatically throw informative errors in case of\nwrong input arguments.\n\n\n## Features\n\ntyped-function has the following features:\n\n- Runtime type-checking of input arguments.\n- Automatic type conversion of arguments.\n- Compose typed functions with multiple signatures.\n- Supports union types, any type, and variable arguments.\n- Detailed error messaging.\n\nSupported environments: node.js, Chrome, Firefox, Safari, Opera, IE11+.\n\n\n## Why?\n\nIn JavaScript, functions can be called with any number and any type of arguments.\nWhen writing a function, the easiest way is to just assume that the function\nwill be called with the correct input. This leaves the function's behavior on\ninvalid input undefined. The function may throw some error, or worse,\nit may silently fail or return wrong results. Typical errors are\n*TypeError: undefined is not a function* or *TypeError: Cannot call method\n'request' of undefined*. These error messages are not very helpful. It can be\nhard to debug them, as they can be the result of a series of nested function\ncalls manipulating and propagating invalid or incomplete data.\n\nOften, JavaScript developers add some basic type checking where it is important,\nusing checks like `typeof fn === 'function'`, `date instanceof Date`, and\n`Array.isArray(arr)`. For functions supporting multiple signatures,\nthe type checking logic can grow quite a bit, and distract from the actual\nlogic of the function.\n\nFor functions dealing with a considerable amount of type checking and conversion\nlogic, or functions facing a public API, it can be very useful to use the\n`typed-function` module to handle the type-checking logic. This way:\n\n-   Users of the function get useful and consistent error messages when using\n    the function wrongly.\n-   The function cannot silently fail or silently give wrong results due to\n    invalid input.\n-   Correct type of input is assured inside the function. The function's code\n    becomes easier to understand as it only contains the actual function logic.\n    Lower level utility functions called by the type-checked function can\n    possibly be kept simpler as they don't need to do additional type checking.\n\nIt's important however not to *overuse* type checking:\n\n-   Locking down the type of input that a function accepts can unnecessarily\n    limit its flexibility. Keep functions as flexible and forgiving as possible,\n    follow the\n    [robustness principle](http://en.wikipedia.org/wiki/Robustness_principle)\n    here: \"be liberal in what you accept and conservative in what you send\"\n    (Postel's law).\n-   There is no need to apply type checking to *all* functions. It may be\n    enough to apply type checking to one tier of public facing functions.\n-   There is a performance penalty involved for all type checking, so applying\n    it everywhere can unnecessarily worsen the performance.\n\n\n## Load\n\nInstall via npm:\n\n    npm install typed-function\n\n\n## Usage\n\nHere are some usage examples. More examples are available in the\n[/examples](/examples) folder.\n\n```js\nvar typed = require('typed-function');\n\n// create a typed function\nvar fn1 = typed({\n  'number, string': function (a, b) {\n    return 'a is a number, b is a string';\n  }\n});\n\n// create a typed function with multiple types per argument (type union)\nvar fn2 = typed({\n  'string, number | boolean': function (a, b) {\n    return 'a is a string, b is a number or a boolean';\n  }\n});\n\n// create a typed function with any type argument\nvar fn3 = typed({\n  'string, any': function (a, b) {\n    return 'a is a string, b can be anything';\n  }\n});\n\n// create a typed function with multiple signatures\nvar fn4 = typed({\n  'number': function (a) {\n    return 'a is a number';\n  },\n  'number, boolean': function (a, b) {\n    return 'a is a number, b is a boolean';\n  },\n  'number, number': function (a, b) {\n    return 'a is a number, b is a number';\n  }\n});\n\n// create a typed function from a plain function with signature\nfunction fnPlain(a, b) {\n  return 'a is a number, b is a string';\n}\nfnPlain.signature = 'number, string';\nvar fn5 = typed(fnPlain);\n\n// use the functions\nconsole.log(fn1(2, 'foo'));      // outputs 'a is a number, b is a string'\nconsole.log(fn4(2));             // outputs 'a is a number'\n\n// calling the function with a non-supported type signature will throw an error\ntry {\n  fn2('hello', 'world');\n}\ncatch (err) {\n  console.log(err.toString());\n  // outputs:  TypeError: Unexpected type of argument.\n  //           Expected: number or boolean, actual: string, index: 1.\n}\n```\n\n\n## Types\n\ntyped-function has the following built-in types:\n\n- `null`\n- `boolean`\n- `number`\n- `string`\n- `Function`\n- `Array`\n- `Date`\n- `RegExp`\n- `Object`\n\nThe following type expressions are supported:\n\n- Multiple arguments: `string, number, Function`\n- Union types: `number | string`\n- Variable arguments: `...number`\n- Any type: `any`\n\n\n## API\n\n### Construction\n\nA typed function can be constructed in two ways:\n\n-   Create from an object with one or multiple signatures:\n\n    ```\n    typed(signatures: Object.<string, function>) : function\n    typed(name: string, signatures: Object.<string, function>) : function\n    ```\n\n-   Merge multiple typed functions into a new typed function:\n\n    ```\n    typed(functions: ...function) : function\n    typed(name: string, functions: ...function) : function\n    ```\n\n    Each function in `functions` can be either a typed function created before,\n    or a plain function having a `signature` property.\n\n\n### Methods\n\n-   `typed.convert(value: *, type: string) : *`\n\n    Convert a value to another type. Only applicable when conversions have\n    been defined in `typed.conversions` (see section [Properties](#properties)). \n    Example:\n    \n    ```js\n    typed.conversions.push({\n      from: 'number',\n      to: 'string',\n      convert: function (x) {\n        return +x;\n    });\n    \n    var str = typed.convert(2.3, 'string'); // '2.3' \n    ```\n\n-   `typed.create() : function`\n\n    Create a new, isolated instance of typed-function. Example:\n    \n    ```js\n    var typed = require('typed-function');  // default instance\n    var typed2 = typed.create();            // a second instance\n    ```\n\n    This would allow you, for example, to have two different type hierarchies\n    for different purposes.\n\n-   `typed.find(fn: typed-function, signature: string | Array) : function | null`\n\n    Find a specific signature from a typed function. The function currently\n    only finds exact matching signatures.\n    \n    For example:\n    \n    ```js\n    var fn = typed(...);\n    var f = typed.find(fn, ['number', 'string']);\n    var f = typed.find(fn, 'number, string');\n    ```\n\n-   `typed.addType(type: {name: string, test: function} [, beforeObjectTest=true]): void`\n\n    Add a new type. A type object contains a name and a test function.\n    The order of the types determines in which order function arguments are \n    type-checked, so for performance it's important to put the most used types \n    first. All types are added to the Array `typed.types`. \n    \n    Example:\n    \n    ```js\n    function Person(...) {\n      ...\n    }\n    \n    Person.prototype.isPerson = true;\n\n    typed.addType({\n      name: 'Person',\n      test: function (x) {\n        return x && x.isPerson === true;\n      }\n    });\n    ```\n\n    By default, the new type will be inserted before the `Object` test\n    because the `Object` test also matches arrays and classes and hence\n    `typed-function` would never reach the new type. When `beforeObjectTest`\n    is `false`, the new type will be added at the end of all tests.\n\n-   `typed.addConversion(conversion: {from: string, to: string, convert: function}) : void`\n\n    Add a new conversion. Conversions are added to the Array `typed.conversions`.\n    \n    ```js\n    typed.addConversion({\n      from: 'boolean',\n      to: 'number',\n      convert: function (x) {\n        return +x;\n    });\n    ```\n\n    Note that any typed functions created before this conversion is added will\n    not have their arguments undergo this new conversion automatically, so it is\n    best to add all of your desired automatic conversions before defining any\n    typed functions.\n\n-   `typed.createError(name: string, args: Array.<any>, signatures: Array.<Signature>): TypeError`\n\n    Generates a custom error object reporting the problem with calling\n    the typed function of the given `name` with the given `signatures` on the\n    actual arguments `args`. Note the error object has an extra property `data`\n    giving the details of the problem. This method is primarily useful in\n    writing your own handler for a type mismatch (see the `typed.onMismatch`\n    property below), in case you have tried to recover but end up deciding\n    you want to throw the error that the default handler would have.\n\n### Properties\n\n-   `typed.types: Array.<{name: string, test: function}>`\n\n    Array with types. Each object contains a type name and a test function.\n    The order of the types determines in which order function arguments are \n    type-checked, so for performance it's important to put the most used types \n    first. Custom types can be added like:\n\n    ```js\n    function Person(...) {\n      ...\n    }\n    \n    Person.prototype.isPerson = true;\n\n    typed.types.push({\n      name: 'Person',\n      test: function (x) {\n        return x && x.isPerson === true;\n      }\n    });\n    ```\n\n-   `typed.conversions: Array.<{from: string, to: string, convert: function}>`\n\n    An Array with built-in conversions. Empty by default. Can be used to define\n    conversions from `boolean` to `number`. For example:\n\n    ```js\n    typed.conversions.push({\n      from: 'boolean',\n      to: 'number',\n      convert: function (x) {\n        return +x;\n    });\n    ```\n\n    Also note the `addConversion()` method above for simply adding a single\n    conversion at a time.\n    \n-   `typed.ignore: Array.<string>`\n\n    An Array with names of types to be ignored when creating a typed function.\n    This can be useful to filter signatures when creating a typed function.\n    For example:\n\n    ```js\n    // a set with signatures maybe loaded from somewhere\n    var signatures = {\n      'number': function () {...},\n      'string': function () {...}\n    }\n\n    // we want to ignore a specific type\n    typed.ignore = ['string'];\n\n    // the created function fn will only contain the 'number' signature \n    var fn = typed('fn', signatures);\n    ```\n\n-   `typed.onMismatch: function`\n\n    The handler called when a typed-function call fails to match with any\n    of its signatures. The handler is called with three arguments: the name\n    of the typed function being called, the actual argument list, and an array\n    of the signatures for the typed function being called. (Each signature is\n    an object with property 'signature' giving the actual signature and\\\n    property 'fn' giving the raw function for that signature.) The default\n    value of `onMismatch` is `typed.throwMismatchError`.\n\n    This can be useful if you have a collection of functions and have common\n    behavior for any invalid call. For example, you might just want to log\n    the problem and continue:\n\n    ```\n    const myErrorLog = [];\n    typed.onMismatch = (name, args, signatures) => {\n      myErrorLog.push(`Invalid call of ${name} with ${args.length} arguments.`);\n      return null;\n    };\n    typed.sqrt(9); // assuming definition as above, will return 3\n    typed.sqrt([]); // no error will be thrown; will return null.\n    console.log(`There have been ${myErrorLog.length} invalid calls.`)\n    ```\n\n    Note that there is only one `onMismatch` handler at a time; assigning a\n    new value discards the previous handler. To restore the default behavior,\n    just assign `typed.onMismatch = typed.throwMismatchError`.\n\n    Finally note that this handler fires whenever _any_ typed function call\n    does not match any of its signatures. You can in effect define such a\n    \"handler\" for a single typed function by simply specifying an implementation\n    for the `...` signature:\n\n    ```\n    const lenOrNothing = typed({\n      string: s => s.length,\n      '...': () => 0\n    });\n    console.log(lenOrNothing('Hello, world!')) // Output: 13\n    console.log(lenOrNothing(57, 'varieties')) // Output: 0\n    ```\n\n### Recursion\n\nThe `this` keyword can be used to self-reference the typed-function:\n\n```js\nvar sqrt = typed({\n  'number': function (value) {\n    return Math.sqrt(value);\n  },\n  'string': function (value) {\n    // on the following line we self reference the typed-function using \"this\"\n    return this(parseInt(value, 10));\n  }\n});\n\n// use the typed function\nconsole.log(sqrt('9')); // output: 3\n```\n\n\n### Output\n\nThe functions generated with `typed({...})` have:\n\n- A function `toString`. Returns well readable code which can be used to see\n  what the function exactly does. Mostly for debugging purposes.\n- A property `signatures`, which holds a map with the (normalized)\n  signatures as key and the original sub-functions as value.\n- A property `name` containing the name of the typed function, if it was\n  assigned one at creation, or an empty string.\n\n\n## Roadmap\n\n### Version 2\n\n- Be able to turn off exception throwing.\n- Extend function signatures:\n  - Optional arguments like `'[number], array'` or like `number=, array`\n  - Nullable arguments like `'?Object'`\n- Create a good benchmark, to get insight in the overhead.\n- Allow conversions to fail (for example string to number is not always\n  possible). Call this `fallible` or `optional`?\n\n### Version 3\n\n- Extend function signatures:\n  - Constants like `'\"linear\" | \"cubic\"'`, `'0..10'`, etc.\n  - Object definitions like `'{name: string, age: number}'`\n  - Object definitions like `'Object.<string, Person>'`\n  - Array definitions like `'Array.<Person>'`\n- Improve performance of both generating a typed function as well as\n  the performance and memory footprint of a typed function.\n\n\n## Test\n\nTo test the library, run:\n\n    npm test\n\n\n## Minify\n\nTo generate the minified version of the library, run:\n\n    npm run minify\n\n\n## Publish\n\n1. Describe the changes in `HISTORY.md`\n2. Increase the version number in `package.json`\n3. Test and build:\n    ```\n    npm install\n    npm run build\n    npm test\n    ```\n4. Verify whether the bundle and minified bundle works correctly by opening\n   `./test/browser.html`  and `./test/browser.min.html` in your browser. \n5. Commit the changes\n6. Merge `develop` into `master`, and push `master`\n7. Create a git tag, and pus this\n8. publish the library:\n    ```\n    npm publish\n    ```\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2014-2018 Jos de Jong\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
    "license": "MIT"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/typed-function/-/typed-function-2.1.0.tgz#ded6f8a442ba8749ff3fe75bc41419c8d46ccc3f",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/typed-function/-/typed-function-2.1.0.tgz",
    "hash": "ded6f8a442ba8749ff3fe75bc41419c8d46ccc3f",
    "integrity": "sha512-bctQIOqx2iVbWGDGPWwIm18QScpu2XRmkC19D8rQGFsjKSgteq/o1hTZvIG/wuDq8fanpBDrLkLq+aEN/6y5XQ==",
    "registry": "npm",
    "packageName": "typed-function",
    "cacheIntegrity": "sha512-bctQIOqx2iVbWGDGPWwIm18QScpu2XRmkC19D8rQGFsjKSgteq/o1hTZvIG/wuDq8fanpBDrLkLq+aEN/6y5XQ== sha1-3tb4pEK6h0n/P+dbxBQZyNRszD8="
  },
  "registry": "npm",
  "hash": "ded6f8a442ba8749ff3fe75bc41419c8d46ccc3f"
}